<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Stick Figures with Animation</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/two.js/0.8.14/two.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/gsap.min.js"></script>
</head>

<body>
  <div id="root_0" style="width: 370px; height: 320px;"></div>
  <script defer>

    class StickFigure {
      constructor() {
        this.group = new Two.Group();

        const headRadius = 20;
        const bodyLength = 50;
        const shoulderDrop = 20;
        const shoulderY = headRadius + shoulderDrop;
        const buttY = headRadius + bodyLength;
        const armLength = 40;
        const armAngle = 45 * (Math.PI / 180);
        const armXOffset = armLength * Math.sin(armAngle);
        const armYOffset = armLength * Math.cos(armAngle);
        const legLength = 60;
        const legAngle = 20 * (Math.PI / 180);
        const legXOffset = legLength * Math.sin(legAngle);
        const legYOffset = legLength * Math.cos(legAngle);

        const head = new Two.Circle(0, 0, headRadius);
        const body = new Two.Line(0, headRadius, 0, buttY);
        const leftLeg = new Two.Line(0, buttY, -legXOffset, buttY + legYOffset);
        const rightLeg = new Two.Line(0, buttY, legXOffset, buttY + legYOffset);
        const leftArm = new Two.Line(0, shoulderY, -armXOffset, shoulderY + armYOffset);
        // right arm is interchangable with pointing arm via opacity
        this.rightArm = new Two.Line(0, shoulderY, armXOffset, shoulderY + armYOffset);

        // pointing arm
        const a = new Two.Anchor(0, shoulderY);
        const b = new Two.Anchor(30, shoulderY);
        const c = new Two.Anchor(30, shoulderY - 40);

        this.pointingArm = new Two.Path([a, b, c]);
        this.pointingArm.fill = 'none';
        this.pointingArm.opacity = 0;

        // talk bubble
        const talkCenterX = 90;
        const talkCenterY = -55;
        const talkWidth = 100;
        const talkHeight = 50;
        const talkLeftX = talkCenterX - talkWidth / 2;
        const talkBottomY = talkCenterY + talkHeight / 2;
        const bubble = new Two.RoundedRectangle(talkCenterX, talkCenterY, talkWidth, talkHeight, 20);
        const talkTail = new Two.Path(
          [
            new Two.Anchor(talkLeftX + 3, talkCenterY + 15),
            new Two.Anchor(talkLeftX - 15, talkBottomY + 15),
            new Two.Anchor(talkLeftX + 15, talkBottomY - 1),
          ],
          false // Closed path
        );
        this.talkText = new Two.Text('', talkCenterX, talkCenterY, {
          size: 22,
          alignment: 'center',
          family: 'Arial'
        });
        this.talkBubble = new Two.Group(bubble, talkTail, this.talkText);
        this.talkBubble.opacity = 0;

        // group
        this.group.add(this.pointingArm, head, body, leftArm, this.rightArm, leftLeg, rightLeg, this.talkBubble);
      }

      speak(visible, text) {
        this.talkText.value = text;
        this.talkBubble.opacity = visible ? 1 : 0;
      }

      point(isPointing) {
        this.pointingArm.opacity = isPointing ? 1 : 0;
        this.rightArm.opacity = isPointing ? 0 : 1;
      }

      async shake(isHorizontal, count, duration) {
        const params = {
          duration,
          repeat: Math.max(1, count - 1),
          yoyo: true,
        };
        if (isHorizontal) {
          params.x = "+=8";
        } else {
          params.y = "+=8";
        }
        gsap.to(this.group.translation, params);
      }

      async walk(targetX, duration) {
        return gsap.to(this.group.translation, {
          x: targetX,
          duration: duration
        })
      }
    }

    class MonteGame {
      constructor(rootID, colorDoors = true) {
        const elem = document.getElementById(rootID);
        const { width, height } = elem.getBoundingClientRect();
        this.two = new Two({ width, height }).appendTo(elem);
        this.colorDoors = colorDoors;
        this.setupScene();
        this.two.add(this.group);
        this.two.update();

        gsap.ticker.add(() => {
          this.two.update();
        });

      }

      setupScene() {
        this.monty = new StickFigure();
        this.monty.group.translation.set(50, 90);

        this.player = new StickFigure();
        this.player.group.translation.set(230, 140);
        this.player.group.linewidth = 4;

        const cardCenterY = 140;
        const cardCentersX = MonteGame.cardCentersX();
        this.doors = cardCentersX.map(x => {
          const card = new Two.RoundedRectangle(x, cardCenterY, 70, 120, 10);
          card.linewidth = 0;
          return card;
        });
        this.group = new Two.Group(this.monty.group, ...this.doors, this.player.group);
        this.scaleScene();
        this.setupGame();
      }

      scaleScene() {
        const bounds = this.group.getBoundingClientRect();
        const viewportWidth = this.two.width;
        const viewportHeight = this.two.height;

        const margin = 0.05;
        const availableWidth = viewportWidth * (1 - 2 * margin);

        const scale = availableWidth / bounds.width;
        this.group.scale = scale;

        const scaledHeight = bounds.height * scale;
        const centerY = (viewportHeight - scaledHeight) / 2;

        this.group.translation.set(
          viewportWidth * margin - bounds.left * scale,
          centerY - bounds.top * scale
        );
      }

      static extents() {
        return { width: 760, height: 620 };
      }

      static cardCentersX() {
        return [150, 230, 310];
      }

      static targetCentersX() {
        return this.cardCentersX().map(x => x - 10);
      }

      setupGame() {
        this.winDoor = Math.floor(Math.random() * 3);
        this.drawDoors();
      }

      drawDoors(gameOver=false) {
        this.doors.forEach((card, i) => {
          if (this.colorDoors || gameOver) {
            card.fill = i == this.winDoor ? '#00F080' : '#DA2F2A';
            card.stroke = i == this.winDoor ? '#00F080' : '#DA2F2A';
          } else {
            card.fill = '#D8D8D8'
            card.linewidth = 2;
            card.stroke = '#0F0F0F';
          }
        });
      }

      async playGame() {
        const pause = s => new Promise(resolve => setTimeout(resolve, 1000 * s));
        this.monty.speak(true, "Choose");
        this.playerChoice = Math.floor(Math.random() * 3);
        const targetX = MonteGame.targetCentersX()[this.playerChoice];
        await this.player.walk(targetX, 0.3);
        this.player.point(true);
        await pause(1);

        this.monty.speak(true, "Switch?");
        const revealable = [0, 1, 2].filter(i => i != this.playerChoice && i != this.winDoor);
        this.revealIndex = revealable[Math.floor(Math.random() * revealable.length)];
        const revealDoor = this.doors[this.revealIndex];
        revealDoor.fill = '#DA2F2A';

        await pause(1);
        const switcher = Math.floor(Math.random() * 2);
        if (switcher) {
          this.playerChoice = [0, 1, 2].filter(i => i != this.playerChoice && i != this.revealIndex)[0];
          const targetX = MonteGame.targetCentersX()[this.playerChoice];
          this.player.walk(targetX, 0.3);
        } else {
          this.player.shake(true, 6, 0.1);
        }

        await pause(1);

        this.doors.forEach((door, i) => {
          door.scale = (i == this.playerChoice) ? 1.1 : 0.75;
          door.opacity = (i == this.playerChoice) ? 1.0 : 0.75;
        });
        this.drawDoors(true);
        const win = this.playerChoice == this.winDoor;
        this.monty.speak(true, win ? 'Win :-)' : 'Lose :-(');
        if (win) {
          this.player.shake(false, 10, 0.1);
        } else {
          this.player.point(false);
        }
      }
    }

    const mg = new MonteGame('root_0', false);
    mg.playGame();

  </script>
</body>

</html>