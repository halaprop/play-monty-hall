<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Stick Figures with Animation</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/two.js/0.8.14/two.min.js"></script>
</head>

<body>
  <div id="root_0" style="border: 1px solid black; width: 370px; height: 320px;"></div>
  <div id="root_1" style="border: 1px solid black; width: 200px; height: 190px;"></div>
  <script defer>

    class StickFigure {
      constructor() {
        this.group = new Two.Group();

        const headRadius = 20;
        const bodyLength = 50;
        const shoulderDrop = 20;
        const shoulderY = headRadius + shoulderDrop;
        const buttY = headRadius + bodyLength;
        const armLength = 40;
        const armAngle = 45 * (Math.PI / 180);
        const armXOffset = armLength * Math.sin(armAngle);
        const armYOffset = armLength * Math.cos(armAngle);
        const legLength = 60;
        const legAngle = 20 * (Math.PI / 180);
        const legXOffset = legLength * Math.sin(legAngle);
        const legYOffset = legLength * Math.cos(legAngle);

        const head = new Two.Circle(0, 0, headRadius);
        const body = new Two.Line(0, headRadius, 0, buttY);
        const leftLeg = new Two.Line(0, buttY, -legXOffset, buttY + legYOffset);
        const rightLeg = new Two.Line(0, buttY, legXOffset, buttY + legYOffset);
        const leftArm = new Two.Line(0, shoulderY, -armXOffset, shoulderY + armYOffset);
        // right arm is interchangable with pointing arm via opacity
        this.rightArm = new Two.Line(0, shoulderY, armXOffset, shoulderY + armYOffset);

        // pointing arm
        const a = new Two.Anchor(0, shoulderY);
        const b = new Two.Anchor(30, shoulderY);
        const c = new Two.Anchor(30, shoulderY - 40);

        this.pointingArm = new Two.Path([a, b, c]);
        this.pointingArm.fill = 'none';
        this.pointingArm.opacity = 0;

        // talk bubble
        const talkCenterX = 90;
        const talkCenterY = -55;
        const talkWidth = 100;
        const talkHeight = 50;
        const talkLeftX = talkCenterX - talkWidth / 2;
        const talkBottomY = talkCenterY + talkHeight / 2;
        const bubble = new Two.RoundedRectangle(talkCenterX, talkCenterY, talkWidth, talkHeight, 20);
        const talkTail = new Two.Path(
          [
            new Two.Anchor(talkLeftX + 3, talkCenterY + 15),
            new Two.Anchor(talkLeftX - 15, talkBottomY + 15),
            new Two.Anchor(talkLeftX + 15, talkBottomY - 1),
          ],
          false // Closed path
        );
        this.talkText = new Two.Text('', talkCenterX, talkCenterY, {
          size: 22,
          alignment: 'center',
          family: 'Arial'
        });
        this.talkBubble = new Two.Group(bubble, talkTail, this.talkText);
        this.talkBubble.opacity = 0;

        // group
        this.group.add(this.pointingArm, head, body, leftArm, this.rightArm, leftLeg, rightLeg, this.talkBubble);
      }

      setPointing(isPointing) {
        this.isPointing = isPointing;
        this.pointingArm.opacity = isPointing ? 1 : 0;
        this.rightArm.opacity = isPointing ? 0 : 1;
      }

      setTalk(visible, value) {
        this.talkText.value = value;
        this.talkBubble.opacity = visible ? 1 : 0;
      }

      // shakeDirection is 'horz', 'vert', or null
      setShaking(shakeDirection, shakeCount = 5) {
        this.shakeDirection = shakeDirection;
        this.shakeCount = shakeCount;
      }

      walkTo(targetX) {
        this.isWalking = true;
        this.targetX = targetX;
      }

      equals(x, y, epsilon = 0.00001) {
        return Math.abs(x - y) < epsilon;
      }

      tick(frameCount) {
        if (this.isWalking) {
          const x = this.group.translation.x;
          if (this.equals(x, this.targetX)) {
            this.group.translation.x = this.targetX;
            this.isWalking = false;
          } else {
            const dX = Math.min(5, (this.targetX - x) / 2.0);
            this.group.translation.x += dX;
          }
        } else if (this.shakeDirection) {
          if (this.shakeCount == 0) {
            this.shakeDirection = null;
          } else {
            if (frameCount % 11 == 0) {
              const delta = this.shakeCount % 2 == 0 ? -8 : 8;
              if (this.shakeDirection == 'horz') {
                this.group.translation.x += delta;
              } else {
                this.group.translation.y += delta;
              }
              this.shakeCount--;
            }
          }
        }
      }
    }

    class MonteGame {
      constructor(rootID) {
        const elem = document.getElementById(rootID);
        const { width, height } = elem.getBoundingClientRect();
        this.two = new Two({ width, height }).appendTo(elem);

        this.setupScene();
        this.two.add(this.group);
        this.two.update();

        this.two.bind('update', frameCount => {
          this.player.tick(frameCount);
        });

        this.two.play();
      }

      setupScene() {
        this.monty = new StickFigure();
        this.monty.group.translation.set(50, 90);

        this.player = new StickFigure();
        this.player.group.translation.set(230, 170);
        this.player.group.linewidth = 4;

        const cardCenterY = 140;
        const cardCentersX = MonteGame.cardCentersX();
        this.doors = cardCentersX.map(x => {
          const card = new Two.RoundedRectangle(x, cardCenterY, 70, 120, 10);
          card.linewidth = 0;
          return card;
        });
        this.group = new Two.Group(this.monty.group, ...this.doors, this.player.group); 
        this.scaleToFixX();
        this.setupGame();
      }

      scaleToFixX() {
        const bounds = this.group.getBoundingClientRect();
        const viewportWidth = this.two.width;
        const viewportHeight = this.two.height;

        const margin = 0.05;
        const availableWidth = viewportWidth * (1 - 2 * margin);

        const scale = availableWidth / bounds.width;
        this.group.scale = scale;

        const scaledHeight = bounds.height * scale;
        const centerY = (viewportHeight - scaledHeight) / 2;

        this.group.translation.set(
          viewportWidth * margin - bounds.left * scale,
          centerY - bounds.top * scale
        );
      }

      static extents() {
        return { width: 760, height: 620 };
      }

      static cardCentersX() {
        return [150, 230, 310];
      }

      static targetCentersX() {
        return this.cardCentersX().map(x => x - 35);
      }

      setupGame() {
        this.winDoor = Math.floor(Math.random() * 3);
        this.doors.forEach((card, i) => {
          card.fill = i == this.winDoor ? '#00F080' : '#DA2F2A';
          card.stroke = i == this.winDoor ? '#00F080' : '#DA2F2A';
        });
      }

      playGame() {
        setTimeout(() => this.monty.setTalk(true, "Choose"), 1000);
        setTimeout(() => {
          this.playerChoice = Math.floor(Math.random() * 3);
          const targetX = MonteGame.targetCentersX()[this.playerChoice];
          this.player.walkTo(targetX);
        }, 1200);
        setTimeout(() => {
          this.player.setPointing(true);
        }, 1500);
        setTimeout(() => {
          this.monty.setTalk(true, 'Switch?');
        }, 2500);
        setTimeout(() => {
          const revealable = [0, 1, 2].filter(i => i != this.playerChoice && i != this.winDoor);
          this.revealIndex = revealable[Math.floor(Math.random() * revealable.length)];
          const revealDoor = this.doors[this.revealIndex];
          revealDoor.fill = 'white';
          revealDoor.linewidth = 3;
        }, 3000);
        setTimeout(() => {
          const switcher = Math.floor(Math.random() * 2);
          if (switcher) {
            this.playerChoice = [0, 1, 2].filter(i => i != this.playerChoice && i != this.revealIndex)[0];
            const targetX = MonteGame.targetCentersX()[this.playerChoice];
            this.player.walkTo(targetX);
          } else {
            this.player.setShaking('horz');
          }
        }, 3500);
        setTimeout(() => {
          this.doors.forEach((door, i) => {
            door.scale = (i == this.playerChoice) ? 1.1 : 0.75;
            door.opacity = (i == this.playerChoice) ? 1.0 : 0.75;
            this.monty.setTalk(true, "Choose");
          });
          const win = this.playerChoice == this.winDoor;
          this.monty.setTalk(true, win ? 'Win :-)' : 'Lose :-(');
          if (win) {
            this.player.setShaking('vert', 10);
          } else {
            this.player.setPointing(false);
          }
        }, 4500);

      }
    }

    const mg = new MonteGame('root_0');
    mg.playGame();

    const mg1 = new MonteGame('root_1');
    mg1.playGame();


  </script>
</body>

</html>