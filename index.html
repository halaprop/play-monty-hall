<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Monty Hall</title>
  <!-- UIkit CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/uikit@3.21.16/dist/css/uikit.min.css" />

  <!-- UIkit JS -->
  <script src="https://cdn.jsdelivr.net/npm/uikit@3.21.16/dist/js/uikit.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/uikit@3.21.16/dist/js/uikit-icons.min.js"></script>

  <script src="https://cdn.plot.ly/plotly-2.35.2.min.js" charset="utf-8"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/two.js/0.8.14/two.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/gsap.min.js"></script>
</head>

<body>
  <nav class="uk-navbar-container" uk-navbar>
    <div class="uk-navbar-left">
      <ul class="uk-navbar-nav">
        <li class="uk-active uk-margin-left"><a href="#">Item</a></li>
        <li class="uk-active uk-margin-left"><a href="#">Item</a></li>
        <li class="uk-active uk-margin-left"><a href="#">Item</a></li>
      </ul>
    </div>
  </nav>

  <div class="uk-container uk-margin-top">
    <div class="uk-grid uk-child-width-1-3@m uk-grid-match" uk-grid>
      <!-- Row 1 -->
      <div>
        <div class="uk-card uk-card-default uk-card-body">
          <h4>Never Switch <span id="lbl-0"></span></h4>
          <hr/>
          <div id="root_0" style="width: 100%;"></div>
          <hr/>
          <div id="chart_0"></div>
        </div>
      </div>
      <div>
        <div class="uk-card uk-card-default uk-card-body">
          <h4>Always Switch <span id="lbl-1"></span></h4>
          <hr/>
          <div id="root_1" style="width: 100%;"></div>
          <hr/>
          <div id="chart_1"></div>
        </div>
      </div>
      <div>
        <div class="uk-card uk-card-default uk-card-body">
          <h4>Coin Flip <span id="lbl-2"></span></h4>
          <hr/>
          <div id="root_2" style="width: 100%;"></div>
          <hr/>
          <div id="chart_2"></div>
        </div>
      </div>
    </div>
  </div>


  <div id="root_0" style="width: 370px; height: 320px;"></div>
  <script defer>

    /*********************************************************************************************************/
    /*********************************************************************************************************/

    class StickFigure {
      constructor() {
        this.group = new Two.Group();

        const headRadius = 20;
        const bodyLength = 50;
        const shoulderDrop = 20;
        const shoulderY = headRadius + shoulderDrop;
        const buttY = headRadius + bodyLength;
        const armLength = 40;
        const armAngle = 45 * (Math.PI / 180);
        const armXOffset = armLength * Math.sin(armAngle);
        const armYOffset = armLength * Math.cos(armAngle);
        const legLength = 60;
        const legAngle = 20 * (Math.PI / 180);
        const legXOffset = legLength * Math.sin(legAngle);
        const legYOffset = legLength * Math.cos(legAngle);

        const head = new Two.Circle(0, 0, headRadius);
        const body = new Two.Line(0, headRadius, 0, buttY);
        const leftLeg = new Two.Line(0, buttY, -legXOffset, buttY + legYOffset);
        const rightLeg = new Two.Line(0, buttY, legXOffset, buttY + legYOffset);
        const leftArm = new Two.Line(0, shoulderY, -armXOffset, shoulderY + armYOffset);
        // right arm is interchangable with pointing arm via opacity
        this.rightArm = new Two.Line(0, shoulderY, armXOffset, shoulderY + armYOffset);

        // pointing arm
        const a = new Two.Anchor(0, shoulderY);
        const b = new Two.Anchor(30, shoulderY);
        const c = new Two.Anchor(30, shoulderY - 40);

        this.pointingArm = new Two.Path([a, b, c]);
        this.pointingArm.fill = 'none';
        this.pointingArm.opacity = 0;

        // talk bubble
        const talkCenterX = 90;
        const talkCenterY = -55;
        const talkWidth = 100;
        const talkHeight = 50;
        const talkLeftX = talkCenterX - talkWidth / 2;
        const talkBottomY = talkCenterY + talkHeight / 2;
        const bubble = new Two.RoundedRectangle(talkCenterX, talkCenterY, talkWidth, talkHeight, 20);
        const talkTail = new Two.Path(
          [
            new Two.Anchor(talkLeftX + 3, talkCenterY + 15),
            new Two.Anchor(talkLeftX - 15, talkBottomY + 15),
            new Two.Anchor(talkLeftX + 15, talkBottomY - 1),
          ],
          false // Closed path
        );
        this.talkText = new Two.Text('', talkCenterX, talkCenterY, {
          size: 22,
          alignment: 'center',
          family: 'Arial'
        });
        this.talkBubble = new Two.Group(bubble, talkTail, this.talkText);
        this.talkBubble.opacity = 0;

        // group
        this.group.add(this.pointingArm, head, body, leftArm, this.rightArm, leftLeg, rightLeg, this.talkBubble);
      }

      speak(visible, text) {
        this.talkText.value = text;
        this.talkBubble.opacity = visible ? 1 : 0;
      }

      point(isPointing) {
        this.pointingArm.opacity = isPointing ? 1 : 0;
        this.rightArm.opacity = isPointing ? 0 : 1;
      }

      async shake(isHorizontal, count, duration) {
        const params = {
          duration,
          repeat: Math.max(1, count - 1),
          yoyo: true,
        };
        if (isHorizontal) {
          params.x = "+=8";
        } else {
          params.y = "+=8";
        }
        gsap.to(this.group.translation, params);
      }

      async walk(targetX, duration) {
        return gsap.to(this.group.translation, {
          x: targetX,
          duration: duration
        })
      }
    }

    /*********************************************************************************************************/
    /*********************************************************************************************************/

    class MonteGame {
      constructor(rootID, colorDoors = true) {
        const elem = document.getElementById(rootID);
        const { width } = elem.getBoundingClientRect();
        const height = width * 0.8;
        this.two = new Two({ width, height }).appendTo(elem);
        this.colorDoors = colorDoors;
        this.setupScene();
        this.two.add(this.group);
        this.two.update();

        gsap.ticker.add(() => {
          this.two.update();
        });

      }

      setupScene() {
        this.monty = new StickFigure();
        this.monty.group.translation.set(50, 90);

        this.player = new StickFigure();
        this.player.group.translation.set(230, 140);
        this.player.group.linewidth = 4;

        const cardCenterY = 140;
        const cardCentersX = MonteGame.cardCentersX();
        this.doors = cardCentersX.map(x => {
          const card = new Two.RoundedRectangle(x, cardCenterY, 70, 120, 10);
          card.linewidth = 0;
          return card;
        });
        this.group = new Two.Group(this.monty.group, ...this.doors, this.player.group);
        this.scaleScene();
        this.setupGame();
      }

      scaleScene() {
        const bounds = this.group.getBoundingClientRect();
        const viewportWidth = this.two.width;
        const viewportHeight = this.two.height;

        const margin = 0.05;
        const availableWidth = viewportWidth * (1 - 2 * margin);

        const scale = availableWidth / bounds.width;
        this.group.scale = scale;

        const scaledHeight = bounds.height * scale;
        const centerY = (viewportHeight - scaledHeight) / 2;

        this.group.translation.set(
          viewportWidth * margin - bounds.left * scale,
          centerY - bounds.top * scale
        );
      }

      static extents() {
        return { width: 760, height: 620 };
      }

      static cardCentersX() {
        return [150, 230, 310];
      }

      static targetCentersX() {
        return this.cardCentersX().map(x => x - 10);
      }

      setupGame() {
        this.winDoor = Math.floor(Math.random() * 3);
        this.player.walk(0, 0)
        this.drawDoors();
      }

      drawDoors(gameOver = false) {
        this.doors.forEach((card, i) => {
          if (this.colorDoors || gameOver) {
            card.fill = i == this.winDoor ? '#487F1E' : '#DA2F2A';
            card.stroke = i == this.winDoor ? '#487F1E' : '#DA2F2A';
          } else {
            card.fill = '#D8D8D8'
            card.linewidth = 2;
            card.stroke = '#0F0F0F';
          }
        });
      }

      async playGame(strategy, pauseLen = 1) {
        const pause = s => new Promise(resolve => setTimeout(resolve, 1000 * s));

        this.setupGame();
        this.monty.speak(true, "Choose");
        this.playerChoice = Math.floor(Math.random() * 3);
        const targetX = MonteGame.targetCentersX()[this.playerChoice];
        await this.player.walk(targetX, 0.3);
        this.player.point(true);
        await pause(pauseLen);

        this.monty.speak(true, "Switch?");
        const revealable = [0, 1, 2].filter(i => i != this.playerChoice && i != this.winDoor);
        this.revealIndex = revealable[Math.floor(Math.random() * revealable.length)];
        const revealDoor = this.doors[this.revealIndex];
        revealDoor.fill = '#DA2F2A';

        await pause(pauseLen);
        let playerWillSwitch;
        if (strategy == 'switcher') playerWillSwitch = true;
        else if (strategy == 'sticker') playerWillSwitch = false;
        else playerWillSwitch = Math.floor(Math.random() * 2);
        if (playerWillSwitch) {
          this.playerChoice = [0, 1, 2].filter(i => i != this.playerChoice && i != this.revealIndex)[0];
          const targetX = MonteGame.targetCentersX()[this.playerChoice];
          this.player.walk(targetX, 0.3);
        } else {
          this.player.shake(true, 6, 0.1);
        }

        await pause(pauseLen);

        this.doors.forEach((door, i) => {
          door.scale = (i == this.playerChoice) ? 1.1 : 0.75;
          door.opacity = (i == this.playerChoice) ? 1.0 : 0.75;
        });
        this.drawDoors(true);
        const win = this.playerChoice == this.winDoor;
        this.monty.speak(true, win ? 'Win :-)' : 'Lose :-(');
        if (win) {
          this.player.shake(false, 10, 0.1);
        } else {
          this.player.point(false);
        }
        await pause(pauseLen);
        return win;
      }

      async playNGames(n, chart, strategy, pauseLen, labelEl) {
        let wins = 0;
        for (let i = 0; i < n; i++) {
          const win = await this.playGame(strategy, pauseLen);
          if (win) wins++;
          const record = wins / (i + 1);
          chart.setValue(record);
          labelEl.innerText = `(${wins} / ${i+1})`;
        }
      }
    }

    /*********************************************************************************************************/
    /*********************************************************************************************************/

    class Chart {
      constructor(rootID) {
        this.rootID = rootID;
        this.value = 0

        this.data = [
          {
            type: "indicator",
            value: this.value,
            delta: { reference: 0 },
            gauge: { axis: { visible: false, range: [0, 1.0] } },
            domain: { x: [0, 1], y: [0, 1] } // Full plot area for a single gauge
          },
        ];

        this.layout = {
          width: 240, // Adjust the width
          height: 190, // Adjust the height
          margin: { t: 0, b: 60, l: 5, r: 5 },
          template: {
            data: {
              indicator: [
                {
                  mode: "number+delta+gauge",
                  delta: { reference: 90 }
                }
              ]
            }
          }
        };
        Plotly.newPlot(this.rootID, this.data, this.layout);
      }

      setValue(value) {
        Plotly.restyle(this.rootID, {
          value: [value],               // New value
          'delta.reference': [this.value] // Use the current value as the new reference
        }, 0);
        this.value = value; // Update `this.value` after the restyle
      }
    }

    const mg0 = new MonteGame('root_0', false);
    const mg1 = new MonteGame('root_1', false);
    const mg2 = new MonteGame('root_2', false);

    const c0 = new Chart('chart_0');
    const c1 = new Chart('chart_1');
    const c2 = new Chart('chart_2');

    const l0 = document.getElementById('lbl-0');
    const l1 = document.getElementById('lbl-1');
    const l2 = document.getElementById('lbl-2');

    mg0.playNGames(1000, c0, 'sticker', 0.25, l0);
    setTimeout(() => mg1.playNGames(1000, c1, 'switcher', 0.25, l1), 100);
    setTimeout(() => mg2.playNGames(1000, c2, 'rando',    0.25, l2), 200);
    
  </script>
</body>

</html>