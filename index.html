<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Monty Hall</title>
  <!-- UIkit CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/uikit@3.21.16/dist/css/uikit.min.css" />

  <!-- UIkit JS -->
  <script src="https://cdn.jsdelivr.net/npm/uikit@3.21.16/dist/js/uikit.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/uikit@3.21.16/dist/js/uikit-icons.min.js"></script>

  <script src="https://cdn.plot.ly/plotly-2.35.2.min.js" charset="utf-8"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/two.js/0.8.14/two.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/gsap.min.js"></script>
</head>

<body>
  <nav class="uk-navbar-container" uk-navbar="mode: click">
    <div class="uk-navbar-left">
      <ul class="uk-margin-left uk-margin-top uk-subnav" uk-switcher="connect: #switcher-content">
        <li><a href="#">Single Game</a></li>
        <li><a href="#">Tournament</a></li>
      </ul>
    </div>
  </nav>

  <div id="switcher-content" class="uk-switcher uk-margin">

    <div class="uk-container uk-margin-top">
      <div class="uk-flex uk-flex-center uk-margin-small-bottom">
        <div id="button-container" class="uk-width-2-3@m uk-text-center" style="height: 54px;">
          <button id="solo-start-btn" class="uk-button uk-button-default">Start</button>
        </div>
      </div>
      <div class="uk-flex uk-flex-center">
        <div class="uk-width-2-3@m">
          <div class="uk-card uk-card-default uk-card-body">
            <div id="root_solo" style="width: 100%;"></div>
          </div>
        </div>
      </div>
    </div>

    <div class="uk-container uk-margin-top">
      <div id="button-container" class="uk-width-1-1@m uk-text-center" style="height: 54px;">
        <button id="play-10-btn" class="uk-button uk-button-default">Play 10</button>
        <button id="play-100-btn" class="uk-button uk-button-default">Play 100</button>
        <button id="play-1000-btn" class="uk-button uk-button-default">Play 1,000</button>
      </div>

      <div class="uk-grid uk-child-width-1-3@m uk-grid-match" uk-grid>
        <div>
          <div class="uk-card uk-card-default uk-card-body">
            <h4>Never Switch <span id="lbl-0"></span></h4>
            <hr />
            <div id="root_0" style="width: 100%;"></div>
            <hr />
            <div id="chart_0"></div>
          </div>
        </div>
        <div>
          <div class="uk-card uk-card-default uk-card-body">
            <h4>Always Switch <span id="lbl-1"></span></h4>
            <hr />
            <div id="root_1" style="width: 100%;"></div>
            <hr />
            <div id="chart_1"></div>
          </div>
        </div>
        <div>
          <div class="uk-card uk-card-default uk-card-body">
            <h4>Coin Flip <span id="lbl-2"></span></h4>
            <hr />
            <div id="root_2" style="width: 100%;"></div>
            <hr />
            <div id="chart_2"></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script defer>

    /*********************************************************************************************************/
    /*********************************************************************************************************/

    class StickFigure {
      constructor() {
        this.group = new Two.Group();

        const headRadius = 20;
        const bodyLength = 50;
        const shoulderDrop = 20;
        const shoulderY = headRadius + shoulderDrop;
        const buttY = headRadius + bodyLength;
        const armLength = 40;
        const armAngle = 45 * (Math.PI / 180);
        const armXOffset = armLength * Math.sin(armAngle);
        const armYOffset = armLength * Math.cos(armAngle);
        const legLength = 60;
        const legAngle = 20 * (Math.PI / 180);
        const legXOffset = legLength * Math.sin(legAngle);
        const legYOffset = legLength * Math.cos(legAngle);

        const head = new Two.Circle(0, 0, headRadius);
        const body = new Two.Line(0, headRadius, 0, buttY);
        const leftLeg = new Two.Line(0, buttY, -legXOffset, buttY + legYOffset);
        const rightLeg = new Two.Line(0, buttY, legXOffset, buttY + legYOffset);
        const leftArm = new Two.Line(0, shoulderY, -armXOffset, shoulderY + armYOffset);
        // right arm is interchangable with pointing arm via opacity
        this.rightArm = new Two.Line(0, shoulderY, armXOffset, shoulderY + armYOffset);

        // pointing arm
        const a = new Two.Anchor(0, shoulderY);
        const b = new Two.Anchor(30, shoulderY);
        const c = new Two.Anchor(30, shoulderY - 40);

        this.pointingArm = new Two.Path([a, b, c]);
        this.pointingArm.fill = 'none';
        this.pointingArm.opacity = 0;

        // talk bubble
        const talkCenterX = 90;
        const talkCenterY = -55;
        const talkWidth = 100;
        const talkHeight = 50;
        const talkLeftX = talkCenterX - talkWidth / 2;
        const talkBottomY = talkCenterY + talkHeight / 2;
        const bubble = new Two.RoundedRectangle(talkCenterX, talkCenterY, talkWidth, talkHeight, 20);
        const talkTail = new Two.Path(
          [
            new Two.Anchor(talkLeftX + 3, talkCenterY + 15),
            new Two.Anchor(talkLeftX - 15, talkBottomY + 15),
            new Two.Anchor(talkLeftX + 15, talkBottomY - 1),
          ],
          false // Closed path
        );
        this.talkText = new Two.Text('', talkCenterX, talkCenterY, {
          size: 22,
          alignment: 'center',
          family: 'Arial'
        });
        this.talkBubble = new Two.Group(bubble, talkTail, this.talkText);
        this.talkBubble.opacity = 0;

        // group
        this.group.add(this.pointingArm, head, body, leftArm, this.rightArm, leftLeg, rightLeg, this.talkBubble);
      }

      speak(visible, text) {
        this.talkText.value = text;
        this.talkBubble.opacity = visible ? 1 : 0;
      }

      point(isPointing) {
        this.pointingArm.opacity = isPointing ? 1 : 0;
        this.rightArm.opacity = isPointing ? 0 : 1;
      }

      async shake(isHorizontal, count, duration) {
        const params = {
          duration,
          repeat: Math.max(1, count - 1),
          yoyo: true,
        };
        if (isHorizontal) {
          params.x = "+=8";
        } else {
          params.y = "+=8";
        }
        gsap.to(this.group.translation, params);
      }

      async walk(targetX, duration) {
        return gsap.to(this.group.translation, {
          x: targetX,
          duration: duration
        })
      }
    }

    /*********************************************************************************************************/
    /*********************************************************************************************************/

    class MonteGame {
      constructor(rootID, colorDoors = true) {
        const elem = document.getElementById(rootID);
        const { width } = elem.getBoundingClientRect();
        const height = width * 0.75;
        this.two = new Two({ width, height }).appendTo(elem);
        this.colorDoors = colorDoors;
        this.setupScene();
        this.two.add(this.group);
        this.two.update();

        gsap.ticker.add(() => {
          this.two.update();
        });

      }

      setupScene() {
        this.monty = new StickFigure();
        this.monty.group.translation.set(60, 0);

        this.player = new StickFigure();
        this.player.group.translation.set(230, 40);
        this.player.group.linewidth = 4;

        const doorCenterY = 40;
        const doorCentersX = MonteGame.doorCentersX();
        this.doors = doorCentersX.map(x => {
          const door = new Two.RoundedRectangle(x, doorCenterY, 70, 120, 10);
          door.linewidth = 0;
          return door;
        });
        this.group = new Two.Group(this.monty.group, ...this.doors, this.player.group);
        this.scaleScene();
        this.setupGame();
      }

      scaleScene() {
        const bounds = this.group.getBoundingClientRect();
        const viewportWidth = this.two.width;
        const viewportHeight = this.two.height;

        const margin = 0.05;
        const availableWidth = viewportWidth * (1 - 2 * margin);

        const scale = availableWidth / bounds.width;
        this.group.scale = scale;

        const scaledHeight = bounds.height * scale;
        const centerY = (viewportHeight - scaledHeight) / 2;

        this.group.translation.set(
          viewportWidth * margin - bounds.left * scale,
          centerY - bounds.top * scale
        );
      }

      static extents() {
        return { width: 760, height: 620 };
      }

      static doorCentersX() {
        return [150, 230, 310];
      }

      static targetCentersX() {
        return this.doorCentersX().map(x => x - 10);
      }

      setupGame() {
        this.winDoor = Math.floor(Math.random() * 3);
        this.player.walk(0, 0)
        this.drawDoors();
      }

      drawDoors(gameOver = false) {
        this.doors.forEach((door, i) => {
          if (this.colorDoors || gameOver) {
            door.fill = i == this.winDoor ? '#487F1E' : '#DA2F2A';
            door.stroke = i == this.winDoor ? '#487F1E' : '#DA2F2A';
          } else {
            door.scale = 1;
            door.fill = '#D8D8D8'
            door.linewidth = 2;
            door.stroke = '#0F0F0F';
          }
        });
      }

      async playGame(strategy, pauseLen = 1) {
        const pause = s => new Promise(resolve => setTimeout(resolve, 1000 * s));

        this.setupGame();
        this.monty.speak(true, "Choose");
        this.playerChoice = Math.floor(Math.random() * 3);
        const targetX = MonteGame.targetCentersX()[this.playerChoice];
        await this.player.walk(targetX, 0.3);
        this.player.point(true);
        await pause(pauseLen);

        this.monty.speak(true, "Switch?");
        const revealable = [0, 1, 2].filter(i => i != this.playerChoice && i != this.winDoor);
        this.revealIndex = revealable[Math.floor(Math.random() * revealable.length)];
        const revealDoor = this.doors[this.revealIndex];
        revealDoor.fill = '#DA2F2A';

        await pause(pauseLen);
        let playerWillSwitch;
        if (strategy == 'switcher') playerWillSwitch = true;
        else if (strategy == 'sticker') playerWillSwitch = false;
        else playerWillSwitch = Math.floor(Math.random() * 2);
        if (playerWillSwitch) {
          this.playerChoice = [0, 1, 2].filter(i => i != this.playerChoice && i != this.revealIndex)[0];
          const targetX = MonteGame.targetCentersX()[this.playerChoice];
          this.player.walk(targetX, 0.3);
        } else {
          this.player.shake(true, 6, 0.1);
        }

        await pause(pauseLen);

        this.doors.forEach((door, i) => {
          door.scale = (i == this.playerChoice) ? 1.1 : 0.75;
          door.opacity = (i == this.playerChoice) ? 1.0 : 0.75;
        });
        this.drawDoors(true);
        const win = this.playerChoice == this.winDoor;
        this.monty.speak(true, win ? 'Win :-)' : 'Lose :-(');
        if (win) {
          this.player.shake(false, 10, 0.1);
        } else {
          this.player.point(false);
        }
        await pause(pauseLen * 2);
        return win;
      }

      async playNGames(n, chart, strategy, pauseLen, labelEl) {
        let wins = 0;
        for (let i = 0; i < n; i++) {
          const win = await this.playGame(strategy, pauseLen);
          if (win) wins++;
          const record = wins / (i + 1);
          chart.setValue(record);
          labelEl.innerText = `(${wins} / ${i + 1})`;
        }
      }

      // user game
      async userStart() {
        this.winDoor = Math.floor(Math.random() * 3);
        this.drawDoors();
        this.player.walk(0, 0);
        this.monty.speak(true, "Choose");

        setButtons([
          { id: 'door-0', text: 'Door A', handler: async e => { await this.userChose(0) } },
          { id: 'door-1', text: 'Door B', handler: async e => { await this.userChose(1) } },
          { id: 'door-2', text: 'Door C', handler: async e => { await this.userChose(2) } }
        ]);

      }

      async userChose(index) {
        const pause = s => new Promise(resolve => setTimeout(resolve, 1000 * s));

        this.playerChoice = index;

        const targetX = MonteGame.targetCentersX()[index];
        await this.player.walk(targetX, 0.3);
        this.player.point(true);

        await pause(0.5);
        this.monty.speak(true, "Switch?");
        setButtons([
          { id: 'switch-btn', text: 'Switch', handler: async e => { await this.userSwitched() } },
          { id: 'stay-btn', text: 'Stay', handler: async e => { await this.userStays() } },
        ]);
        await pause(0.5);

        const revealable = [0, 1, 2].filter(i => i != this.playerChoice && i != this.winDoor);
        this.revealIndex = revealable[Math.floor(Math.random() * revealable.length)];
        const revealDoor = this.doors[this.revealIndex];
        revealDoor.fill = '#DA2F2A';
      }

      async userSwitched() {
        setButtons([]);
        this.playerChoice = [0, 1, 2].filter(i => i != this.playerChoice && i != this.revealIndex)[0];
        const targetX = MonteGame.targetCentersX()[this.playerChoice];
        this.player.walk(targetX, 0.3);
        this.userEndGame();
      }

      async userStays() {
        setButtons([]);
        this.player.shake(true, 6, 0.1);
        this.userEndGame();
      }

      async userEndGame() {
        const pause = s => new Promise(resolve => setTimeout(resolve, 1000 * s));
        await pause(1);

        this.doors.forEach((door, i) => {
          door.scale = (i == this.playerChoice) ? 1.1 : 0.75;
          door.opacity = (i == this.playerChoice) ? 1.0 : 0.75;
        });
        this.drawDoors(true);
        const win = this.playerChoice == this.winDoor;
        this.monty.speak(true, win ? 'Win :-)' : 'Lose :-(');
        if (win) {
          this.player.shake(false, 10, 0.1);
        } else {
          this.player.point(false);
        }
        setButtons([
          { id: 'start-btn', text: 'Replay', handler: async e => { await this.userStart() } }
        ]);
      }

    }

    /*********************************************************************************************************/
    /*********************************************************************************************************/

    class Chart {
      constructor(rootID) {
        this.rootID = rootID;
        this.value = 0

        this.data = [
          {
            type: "indicator",
            value: this.value,
            delta: { reference: 0 },
            gauge: { axis: { visible: false, range: [0, 1.0] } },
            domain: { x: [0, 1], y: [0, 1] } // Full plot area for a single gauge
          },
        ];

        this.layout = {
          width: 240, // Adjust the width
          height: 190, // Adjust the height
          margin: { t: 0, b: 60, l: 5, r: 5 },
          template: {
            data: {
              indicator: [
                {
                  mode: "number+delta+gauge",
                  delta: { reference: 90 }
                }
              ]
            }
          }
        };
        Plotly.newPlot(this.rootID, this.data, this.layout);
      }

      setValue(value) {
        Plotly.restyle(this.rootID, {
          value: [value],               // New value
          'delta.reference': [this.value] // Use the current value as the new reference
        }, 0);
        this.value = value; // Update `this.value` after the restyle
      }
    }

    let soloMG;

    let mg0, mg1, mg2;
    let c0, c1, c2;
    let l0, l1, l2;

    function presentTournament() {
      mg0 = new MonteGame('root_0', true);
      mg1 = new MonteGame('root_1', true);
      mg2 = new MonteGame('root_2', true);

      c0 = new Chart('chart_0');
      c1 = new Chart('chart_1');
      c2 = new Chart('chart_2');

      l0 = document.getElementById('lbl-0');
      l1 = document.getElementById('lbl-1');
      l2 = document.getElementById('lbl-2');
    }

    function startTournament(count) {
      mg0.playNGames(count, c0, 'sticker', 0.25, l0);
      setTimeout(() => mg1.playNGames(count, c1, 'switcher', 0.25, l1), 100);
      setTimeout(() => mg2.playNGames(count, c2, 'rando', 0.25, l2), 200);
    }

    UIkit.util.on(document, 'shown', (event) => {
      const switcher = document.querySelector('[uk-switcher]');
      if (switcher) {
        const activeIndex = UIkit.switcher(switcher).index();
        if (activeIndex == 1 && !mg0) {
          presentTournament();
        }
      }
    });

    function setButton(button) {
      document.getElementById('button-container').insertAdjacentHTML(
        'beforeend',
        `<button id="${button.id}" class="uk-button uk-button-default">${button.text}</button>`
      );
      const newButton = document.getElementById(button.id);
      if (newButton) {
        newButton.addEventListener('click', button.handler);
      }
    }

    function setButtons(buttons) {
      document.getElementById('button-container').innerHTML = '';
      buttons.forEach(setButton);
    }

    soloMG = new MonteGame('root_solo', false);
    document.getElementById('solo-start-btn').addEventListener('click', e => {
      soloMG.userStart();
    });

    document.getElementById('play-10-btn').addEventListener('click', e => startTournament(10));
    document.getElementById('play-100-btn').addEventListener('click', e => startTournament(100));
    document.getElementById('play-1000-btn').addEventListener('click', e => startTournament(1000));

  </script>
</body>

</html>